grammar de.itemis.tooling.asp.ASP with org.eclipse.xtext.common.Terminals

generate aSP "http://www.itemis.de/tooling/asp/ASP"

//TODO query?
//TODO function and classical literal are ambiguous as both can have the form
// f(t,t,t) hence it is impossible to decide what to instantiate
//eg. :-f(t)  vs  :-f(t)<3

//This is why we relax a number of rules syntactically
//classical literal is simply a term etc.
//that way we get backtracking-free parser
//the rest has to be enforced via validation
Program: statements+=Statement*;

Statement:Rule | Optimize| WRule;

//Rule covers first two statement lines
Rule:{Rule}(
		(head=Head (':-' (body=Body)?)?)
			| 
		(':-' (body=Body)?)
	) '.'
;


//WRule covers Line 3
WRule: ':~' body=Body? '.' '[' weight=Weight']';


Body: elements+=BodyElement (=>',' elements+=BodyElement)*;
//TODO validation that only allowed elements are default-negated
BodyElement: (defaultNegated?='not')? positive=PosBodyElement;

//TODO check Term structure of PosBodyElement (Function or negated Function)
PosBodyElement:
		//aggregate without left comparator
		({Aggregate} function=AggregateFunction
			=>'{' (elements+=AggregateElement (=>';' elements+=AggregateElement)*)?'}' (rightBinop=Binop rightTerm=Term)?
		)
		|
		//classicalLiteral
		Term
		//aggregate with left comparator or builtin
		({CompareStart.left=current} op=Binop
			(
				({Aggregate.leftComp=current} function=AggregateFunction
				=>'{' (elements+=AggregateElement (=>';' elements+=AggregateElement)*)?'}' (rightBinop=Binop rightTerm=Term)?
				)
				|
				({BuiltinAtom.leftAndOp=current} right=Term)
			)
		)?
;

Head: 
	(
		'{'{Choice}(elements+=ChoiceElement (=>';' elements+=ChoiceElement)*)?
		'}' (rightBinop=Binop rightTerm=Term)?
	)
	|
	//classical literal
	Term
	(
		({Choice.leftTerm=current}leftBinop=Binop
			'{'(elements+=ChoiceElement (=>';' elements+=ChoiceElement)*)?
			'}' (rightBinop=Binop rightTerm=Term)?
		)
		|
		({Disjunction.literal+=current}(=>'|' literal+=Term/*ClassicalLiteral*/)+)
	)?
	
//	Disjunction | Choice
;
//
//Disjunction: literal+=ClassicalLiteral (=>'|' literal+=ClassicalLiteral)*;
//
//Choice: (leftTerm=Term leftBinop=Binop )?
//	'{' elements+=ChoiceElement (=>';' elements+=ChoiceElement)'}' (rightBinop=Binop rightTerm=Term)?;

//TODO check head for struture
ChoiceElement: head=Term/*ClassicalLiteral*/ (':' bodyElement+=NafLiteral (=>',' bodyElement+=NafLiteral)*)?;


//CompareStart:left=Term op=Binop;
//BuiltinAtom:leftAndOp=CompareStart =>right=Term;

AggregateElement:
	(terms+=Term (=>',' terms+=Term)* (=>':' (literals+=NafLiteral (=>',' literals+=NafLiteral)*)?)?)
		|
	(':' {AggregateElement} (literals+=NafLiteral (=>',' literals+=NafLiteral)*)?)
;

//TODO validation, code completion; count, sum, min, max
AggregateFunction hidden():'#'ID;

//TODO inline function->OptimizeMax: ('maximize'|'maximise')...?
Optimize: function=OptimizeFunction '{'(elements+=OptimizeElement (';' elements+=OptimizeElement))? '}''.';
OptimizeElement: weight=Weight (':' (literals+=NafLiteral (',' literals+=NafLiteral)*)?)?;

enum OptimizeFunction:max="#maximize"|max="#maximise"|min='#minimise'|min='#minimize';

Weight: term=Term ('@'atTerm=Term)? (',' commaTerms+=Term)*;

//TODO check Builtin not default negated
NafLiteral:(defaultNegated?='not')? positive=PosNafElement;

//TODO check Term structure only function or negated function
PosNafElement:Term ({CompareStart.left=current} op=Binop {BuiltinAtom.leftAndOp=current} right=Term)?;

//check function or negated function
//TODO remove: we cannot check "instanceOf ClassicalTerm" anyway
//ClassicalLiteral returns ClassicalLiteral: Term;


enum Binop:equal='=='|unequal='<>'|unequal='!='|less='<'|greater='>'|lesseq='<='|greatereq='>=';

Term: AdditionTerm;

AdditionTerm returns Term:
	MultiplicationTerm ({AdditionTerm.left=current} ('+'|'-') right=MultiplicationTerm )?
;

MultiplicationTerm returns Term:
	UnaryTerm ({Multiplication.left=current} ('*'|'/') right=MultiplicationTerm)?
;

UnaryTerm returns Term:
	('-'{NegatedTerm} negated=PrimaryTerm)
	|PrimaryTerm
;

PrimaryTerm returns Term:
	Function|
	Number|
	StringTerm|
	Variable|
	AnonymousVariable
	|ParenthesisTerm
;

Number:value=INT;
StringTerm:value=STRING;
Variable:value=UCID;
AnonymousVariable:{AnonymousVariable}'_';
//TODO check
ParenthesisTerm returns Term:'('Term')';

Function:name=ID ('('(terms+=Term (','terms+=Term)*)?')')?;

terminal ID: ('a'..'z') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
terminal UCID: ('A'..'Z') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;

terminal ML_COMMENT	: '%*' -> '*%';
terminal SL_COMMENT 	: '%' !('\n'|'\r')* ('\r'? '\n')?;