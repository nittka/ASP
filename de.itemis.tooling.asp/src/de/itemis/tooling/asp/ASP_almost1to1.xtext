grammar de.itemis.tooling.asp.ASP with org.eclipse.xtext.common.Terminals

generate aSP "http://www.itemis.de/tooling/asp/ASP"

//TODO query?
//TODO function and classical literal are ambiguous as both can have the form
// f(t,t,t) hence it is impossible to decide what to instantiate
//eg. :-f(t)  vs  :-f(t)<3
Program: statements+=Statement*;

Statement:((Rule | Optimize)=>'.')| WRule;

//Rule covers first two statement lines
Rule: (head=Head (':-' (body=Body)?)?)
		| 
	({Rule}':-' (body=Body)?)
;
//WRule covers Line 3
WRule: ':~' body=Body? '.' '[' weight=Weight']';

Head: Disjunction | Choice;

Body: elements+=BodyElement (=>',' elements+=BodyElement)*;
//negation inside Aggregate as Aggregate is not called elsewhere
//TODO both alternatives can start with Term Binop, hence ambiguity
BodyElement:NafLiteral|Aggregate;

Disjunction: literal+=ClassicalLiteral (=>'|' literal+=ClassicalLiteral)*;


Choice: (leftTerm=Term leftBinop=Binop )?
	'{' (elements+=ChoiceElement (=>';' elements+=ChoiceElement)*)?'}' (rightBinop=Binop rightTerm=Term)?;

ChoiceElement: head=ClassicalLiteral (':' bodyElement+=NafLiteral (=>',' bodyElement+=NafLiteral)*)?;

//negation here rather than in BodyElement, as Aggregate is not called elsewhere
//TODO remove overlap with NafLiteral
Aggregate:(negated?='not')? (leftTerm=Term leftBinop=Binop )? function=AggregateFunction
	=>'{' (elements+=AggregateElement (=>';' elements+=AggregateElement)*)?'}' (rightBinop=Binop rightTerm=Term)?
;

AggregateElement:
	(terms+=Term (=>',' terms+=Term)* (=>':' (literals+=NafLiteral (=>',' literals+=NafLiteral)*)?)?)
		|
	(':' {AggregateElement} (literals+=NafLiteral (=>',' literals+=NafLiteral)*)?)
;

//TODO validation, code completion; count, sum, min, max
AggregateFunction hidden():'#'ID;

//TODO inline function->OptimizeMax: ('maximize'|'maximise')...?
Optimize: function=OptimizeFunction '{'(elements+=OptimizeElement (';' elements+=OptimizeElement))? '}';
OptimizeElement: weight=Weight (':' (literals+=NafLiteral (',' literals+=NafLiteral)*)?)?;

enum OptimizeFunction:max="#maximize"|max="#maximise"|min='#minimise'|min='#minimize';

Weight: term=Term ('@'atTerm=Term)? (',' commaTerms+=Term)*;

NafLiteral:ClassicalLiteral|DefNegatedClassicalLiteral|BuiltinAtom;

DefNegatedClassicalLiteral: 'not' ClassicalLiteral;

ClassicalLiteral: (negated?='-')? name=ID ('('(terms+=Term (','terms+=Term)*)?')')?;

BuiltinAtom:left=Term op=Binop =>right=Term;

enum Binop:equal='=='|unequal='<>'|unequal='!='|less='<'|greater='>'|lesseq='<='|greatereq='>=';

Term: AdditionTerm;

AdditionTerm returns Term:
	MultiplicationTerm ({AdditionTerm.left=current} ('+'|'-') right=MultiplicationTerm )?
;

MultiplicationTerm returns Term:
	UnaryTerm ({Multiplication.left=current} ('*'|'/') right=MultiplicationTerm)?
;

UnaryTerm returns Term:
	('-'{NegatedTerm}negated=PrimaryTerm)
	|PrimaryTerm
;

PrimaryTerm returns Term:
	Function|
	Number|
	StringTerm|
	Variable|
	AnonymousVariable
	|ParenthesisTerm
;

Number:value=INT;
StringTerm:value=STRING;
Variable:value=UCID;
AnonymousVariable:{AnonymousVariable}'_';
ParenthesisTerm returns Term:'('Term')';

Function:name=ID ('('(terms+=Term (','terms+=Term)*)?')')?;

terminal ID: ('a'..'z') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
terminal UCID: ('A'..'Z') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;

terminal ML_COMMENT	: '%*' -> '*%';
terminal SL_COMMENT 	: '%' !('\n'|'\r')* ('\r'? '\n')?;
